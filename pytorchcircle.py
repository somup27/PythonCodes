# -*- coding: utf-8 -*-
"""pytorchcircle

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-UOSxmWhC3HxwyWlY92IRElNEz5a_bqh
"""

import random

train_data = []
expected = []
for i in range(20000):
    x = random.uniform(-1.5,1.5)
    y = random.uniform(-1.5,1.5)
    train_data.append([x,y])
    if x ** 2 + y ** 2 > 1:
        expected.append([0.0])
    else:
        expected.append([1.0])

layerct = [2,6,8,1,1]

import torch

ins = torch.tensor(train_data)
print(ins)
expected = torch.tensor(expected)
print(expected)

thenn = []
for i in range(1,len(layerct)):
  thenn.append(torch.nn.Linear(layerct[i-1],layerct[i],bias=False))
  if i < len(layerct) -1 :
    thenn.append(torch.nn.Sigmoid())
print(thenn)
mynn = torch.nn.Sequential(*thenn)
criterion = torch.nn.MSELoss()

optimizer = torch.optim.Adam(mynn.parameters(),lr=.005)
for epoch in range(2000000):
  y_pred = mynn(ins)
  loss = criterion(y_pred,expected)
  if not epoch%500 or epoch<10:
    print('epoch: ',epoch,' loss: ',loss.item())
  optimizer.zero_grad()
  loss.backward()
  optimizer.step()

for k,v in mynn.state_dict().items():
  print (k,v)
testset = []
testtest = []
for i in range(100000):
    test = [random.uniform(-1.5,1.5),random.uniform(-1.5,1.5)]
    if test[0] ** 2 + test[1] ** 2 > 1:
      testtest.append([0])
    else:
      testtest.append([1])
    testset.append(test)
y = mynn(torch.tensor(testset))
mistakes = 0
for i in range(len(testtest)):
  output = 0
  if y[i].item() > 0.5:
    output = 1
  if output != testtest[i][0]:
    mistakes += 1
print(mistakes)

